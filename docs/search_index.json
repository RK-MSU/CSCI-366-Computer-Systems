[["366-Computer-Systems.html", "CSCI 366 Computer Systems Welcome Quiz 5 Course Introduction Writing Code Git Project Overview Github &amp; Markdown Linux Command Line Building Code Testing Code Re-introduction to C Functions in C Bits and Bitmasks Pointers &amp; Arrays Strings &amp; Structs Project Help The Stack &amp; The Heap Memory Segments In C The Stack Networking (Sockets) Concurrency in C Introduction to Assembler Math Labels Storing &amp; Manipulating Binary Data The 8086 chip 8086 Registers Implementing A Bit Bytes, Hex &amp; Integer Representations Bytes ASCII HEX Floating Point The CPU References", " CSCI 366 Computer Systems River Kelly Spring 2021 Welcome Quiz 5 For the quiz tomorrow, please review the following things: How to convert a number from decimal (e.g. 42) to an 8 bit unsigned binary integer How to convert a number from decimal (e.g. -42) to an 8 bit two’s complement integer How to interpret a 16 bit floating point number in terms of decimal Course Introduction Writing Code Git Project Overview Github &amp; Markdown Linux Command Line Building Code Testing Code Re-introduction to C Functions in C Bits and Bitmasks Pointers &amp; Arrays Strings &amp; Structs Project Help The Stack &amp; The Heap How Data is Stored in C Programs Memory Segments In C C has different segments of memory Code segment (aka Text Segment) - the instructions of the program are stored here, typically read only! Data &amp; BSS segments - global and static variables are stored here Known, fixed size BSS is zero initialized The Stack - where function parameters, local variables and other function related information is stored The Heap - an area where dynamically allocated memory lives The Stack The stack is where function-related information is store Parameters Kind of - See x64 calling conventions Local variables for a function Return values from functions Return address to jump to when function returns (hidden from us, to an extent) Recall a stack data structure The operations on a stack are Add to the top of the stack Remove from the top of the stack Look At the current top of the stack You can’t access a plate that isn’t at the top of the stack A C function can’t access variables not declared in the current Stack Frame A debugger can though, by using data stored in the stack :) In C, the stack is managed by the C runtime When you make a function call, a few things happen: The address of the next instruction is pushed onto the stack A Stack Frame is allocated for the new function Parameters are passed appropriately The CPU then jumps to the function being called A stack frame has been pushed onto the stack When the function completes, the stack frame is deallocated and the CPU jumps back to the return location This is how come automatic variables are automatically reclaimed: the data lives on the stack and go away when the stack frame goes away A recursive function demo makes some things clear Notice that each function call has its own copies of the parameter i and the local variable i_address What do you notice about i_address? Networking (Sockets) Concurrency in C Introduction to Assembler Resources: Little Man Computer NASM Tutorial Math ADD: 1XX - adds the value stored in location XX to whatever value is currently in the Accumulator SUB: 2XX - subtracts the value stored in location XX from whatever value is in the Accumulator STA: 3XX - stores the value in the Accumulator into the memory location XX LDA: 5XX - loads the value in the memory location XX into the Accumulator BRA: 6XX - unconditionally sets the Program Counter to the memory location XX BRZ: 7XX - branches to the location XX if the accumulator is zero BRP: 8xx - branches to the location XX if the accumulator is 0 or positive INP: 901 - Ask the user for numeric input, to be stored in the Accumulator OUT: 902 - Write the current accumulator value to the output area HLT/COB: 000 - end the program, halt, take a coffee break Labels A nice way to avoid having to hard code addresses into your assembly program Provide a symbolic way to refer to jump targets or data loads Here we are storing 42 at the 4th position and loading it via a label Labels also become important as we implement things like loops or conditional branches in our assembly program Examples: LDA ANSWER OUT HLT ANSWER DAT 42 Add One Our first program is going to be extremely simple Ask the user for a number, add one to it, and then output the number INP ADD ONE OUT HLT ONE DAT 1 INP - get user input and put it in the accumulator ADD ONE - add the number stored at the label ONE to the value in the accumulator OUT - output the value in the accumulator to the output area HLT - stop execution ONE DAT 1 - Store the value 1 at the “current” position and make it available for reference with the label “ONE” Count Down: Let’s do something more complex: Print the numbers 10 to 1 in decreasing order LDA TEN LOOP BRZ EXIT OUT SUB ONE BRA LOOP EXIT HLT ONE DAT 1 TEN DAT 10 LDA - load the number 10 into the accumulator BRZ - If the accumulator is 0, branch to EXIT OUT - Else, print the accumulator SUB - subtract 1 from the accumulator BRA - unconditionally jump back to the start of the loop HLT - Halt (exit) ONE, TEN - Data slots to hold constants This demonstrates two higher level programming language concepts: Conditional logic (if statements) Looping (for, do, while) Compilers take your higher level programming language constructs, like the while loop in C, and create instructions like this Max: “Ask the user for two numbers and print the maximum of the two” INP STA 99 INP STA 98 SUB 99 BRP LOAD_2ND LDA 99 BRA PRINT LOAD_2ND LDA 98 PRINT OUT HLT Storing &amp; Manipulating Binary Data The implementation of registers in the 8086 chip The implementation of an adder (half and full) circuit The 8086 chip Produced by intel from 1978 to 1998 16 bit chip Supported 20 bit addressing First in a series of x86 chips which, unexpectedly, would take over the world Chip was a reaction to the delay of the iAPX 432 chip iAPX 432 was an interesting chip No user-facing registers Stack machine Hardware support for garbage collection, object oriented programming A wonderful tear-down of an original 8086 chip: http://www.righto.com/2020/07/the-intel-8086-processors-registers.html 8086 Registers Registers, as we know, are very fast memory stores located close to the CPU CPUs use registers for storing and mutating data As with all binary systems, data is stored in 1s and 0s NOT gate implementation The in wire, when activated, opens a channel to ground, causing current to flow to ground When not activated, the channel is blocked, so current flows to out You can see how this inverts the signal on in Physical layout of a NOT gate Ground and +5 carry electric current Current on IN opens the resistor, causing current to flow to ground, rather than out Implementing A Bit How can we implement a stable bit value using NOT gates? Chain them! If top is 0, it will stay 0 as it goes through the bottom gate And vice versa Adding reading and writing to the bit value A read gate A write gate When read gate is open, the the value is written to the bit line When write gate is open, the value of the bit line is written to the register Bytes, Hex &amp; Integer Representations Representing and manipulating binary data Bytes The smallest group of bits is known as a byte A byte is 8 bits With 8 bits available we can represent 2^8 numbers 0-255 unsigned Interpreting this value as an unsigned integer this value is: \\((10110001)_{2} = (1 × 2^{7}) +\\) \\((0 × 2^{6}) + (1 × 2^{5}) + (1 × 2^{4}) +\\) \\((0 × 2^{3}) + (0 × 2^{2}) + (0 × 2^{1}) +\\) \\((1 × 2^{0}) = (177)_{10}\\) ASCII ASCII is an example of a representation imposed on bytes Developed from telegraph code Work on standard began in 1960 Encodes 128 English characters into 7 bit integers ASCII codes are shown at right When you work with string literals in C, this is what is actually being stored in memory NB: you can treat these as unsigned integers We do that when converting a numeric char to its actual numeric value in the project! HEX Hexadecimal is another way to represent binary data Unrelated to ASCII Rather, an efficient way to specify groups of 4 bytes Uses 16 characters to represent a half byte (a nibble) 0-9, then A-F In written representation, hex is typically prefixed with an 0x: 0x00F You can use this notation as a literal value in C, Java, etc. Floating Point The CPU References "]]
